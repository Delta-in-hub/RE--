# Regex

## 修改dfa/nfa,支持.匹配任何字符
## 第一遍parse
- [xyz] 展开为 (x|y|z)
- [0-3] 展开为 (0|1|2|3)
- [0-2a-c] (0|1|2|a|b|c)
- 处理转义`\`
- '\t' char(9)
- `\n` char(10)
- `\w` [A-Za-z0-9_]
- `\d`  [0-9]
- `\[` [
- `\]` ]
- 将特殊字符映射到ascii的不可见字符
```c++
const std::unordered_map<char, char> nfaRE::ESCAPE{
    {18, '*'},
    {19, '.'},
    {20, '+'},
    {21, '?'},
    {22, '|'},
    {23, '('},
    {24, ')'},
};
```
## 第二遍parse
处理`{n,m}`
- (e1){2}  (e1)(e1)
- (e1){0,}  (e1)*
- (e1){1,}  (e1)+
- (e1){2,3}  ((e1)(e1)|(e1)(e1)(e1))


## 然后?
对之前的dfa/nfa进行修改
